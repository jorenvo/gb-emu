import { CPU } from "./cpu";
import { Memory } from "./memory";
import * as utils from "./utils";

export abstract class Instruction {
  protected address: number;

  constructor(address: number) {
    this.address = address;
  }

  moveSPToNext(cpu: CPU) {
    cpu.SP += this.size();
  }

  abstract size(): number;
  abstract exec(cpu: CPU, memory: Memory): void;
  abstract disassemble(memory: Memory): string;
}

export class NotImplemented extends Instruction {
  size() {
    return 0;
  }

  exec(_cpu: CPU, memory: Memory) {
    utils.log(
      this.address,
      `Executing not implemented instruction with opcode ${memory.getByte(
        this.address
      )}`
    );
  }

  disassemble(memory: Memory) {
    return `NIP ${memory.getByte(this.address)}`;
  }
}

export class OpNop extends Instruction {
  size() {
    return 1;
  }

  exec(_cpu: CPU, _memory: Memory) {}

  disassemble(_memory: Memory) {
    return "NOP";
  }
}

export class OpLdD16ToR16 extends Instruction {
  size() {
    return 3;
  }

  exec(cpu: CPU, memory: Memory) {
    const d16High = memory.getByte(this.address + 1);
    const d16Low = memory.getByte(this.address + 2);

    if (memory.getByte(this.address) === 0x31) {
      cpu.SP = (d16High << 8) | d16Low;
    } else {
      const register = cpu.getBits(memory.getByte(this.address), 4, 5) * 2;
      cpu.regs[register] = d16High;
      cpu.regs[register + 1] = d16Low;
      this.moveSPToNext(cpu);
    }
  }

  disassemble(memory: Memory) {
    let reg;
    switch (memory.getByte(this.address) >> 4) {
      case 0x0:
        reg = "BC";
        break;
      case 0x1:
        reg = "DE";
        break;
      case 0x2:
        reg = "HL";
        break;
      case 0x3:
        reg = "SP";
        break;
      default:
        throw new Error("Unknown register!");
    }

    const d16Hex = utils.hexString(
      (memory.getByte(this.address + 1) << 8) |
        memory.getByte(this.address + 2),
      16
    );
    return `LD ${reg}, $${d16Hex}`;
  }
}

// autogenerated classes start here
export class OpLdD8ToR8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = memory.getByte(this.address) * 2;
    const d8 = memory.getByte(cpu.PC++);
    if (memory.getByte(this.address) === 0x36) {
      memory.setByte(cpu.HL, d8);
    } else {
      cpu.regs[register] = d8;
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdR8ToA16 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    let register = 0;
    switch (memory.getByte(this.address)) {
      case 0x02:
        register = 0;
        break;
      case 0x12:
        register = 2;
        break;
      case 0x22:
      case 0x32:
      case 0x77:
        register = 4;
        break;
      default:
        cpu.log(
          memory.getByte(this.address),
          "opLdR8ToA16 with unknown memory.getByte(this.address)"
        );
    }
    const high = cpu.regs[register];
    const low = cpu.regs[register + 1];
    let addr = (high << 8) | low;
    memory.setByte(addr, cpu.regs[CPU.A]);

    switch (memory.getByte(this.address)) {
      case 0x22:
        ++cpu.HL;
        break;
      case 0x32:
        --cpu.HL;
        break;
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdA16ToA extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = memory.getByte(this.address) * 2;
    const aHigh = cpu.regs[register];
    const aLow = cpu.regs[register + 1];
    let addr = (aHigh << 8) | aLow;
    cpu.regs[CPU.A] = memory.getByte(addr);

    switch (memory.getByte(this.address)) {
      case 0x2a:
        ++cpu.HL;
        break;
      case 0x3a:
        --cpu.HL;
        break;
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdAtoAddrC extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    memory.setByte(CPU.C, cpu.regs[CPU.A]);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdSPToA16 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const a16Low = memory.getByte(cpu.PC++);
    const a16High = memory.getByte(cpu.PC++);
    const a16 = (a16High << 8) | a16Low;
    memory.setByte(a16, cpu.SP & 0xff); // TODO: this order is correct, should we always store LSB before MSB?
    memory.setByte(a16 + 1, cpu.SP >> 8);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdhA8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const lowAddr = memory.getByte(cpu.PC++);
    memory.setByte(0xff00 | lowAddr, cpu.regs[CPU.A]);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpLdR8ToR8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const srcReg = cpu.getBits(memory.getByte(this.address), 0, 2);
    const destReg = cpu.getBits(memory.getByte(this.address), 3, 5);

    if (srcReg === 6) {
      cpu.regs[destReg] = cpu.HLIndirect;
    } else if (destReg === 6) {
      cpu.HLIndirect = cpu.regs[srcReg];
    } else {
      cpu.regs[destReg] = cpu.regs[srcReg];
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpDecInc16 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    // TODO: SP will be 0x3, check if that works
    const register = memory.getByte(this.address) * 2;
    const high = cpu.regs[register];
    const low = cpu.regs[register + 1];

    let r16 = (high << 8) | low;
    r16 += inc ? 1 : -1;
    cpu.regs[register] = r16 >> 8;
    cpu.regs[register + 1] = r16 & 0xff;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpInc16 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x33) {
      ++cpu.SP;
    } else {
      cpu.opDecInc16(memory.getByte(this.address), true);
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpDec16 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.opDecInc16(memory.getByte(this.address), false);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpInc8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x34) {
      let addr = cpu.HLIndirect;
      cpu.setHalfCarryFlag(memory.getByte(addr), 1);
      memory.getByte(addr) += 1;
      cpu.setZeroFlag(memory.getByte(addr) === 0 ? 1 : 0);
    } else {
      const register = memory.getByte(this.address) * 2;
      cpu.setHalfCarryFlag(cpu.regs[register], 1);
      cpu.regs[register] += 1;
      cpu.setZeroFlag(cpu.regs[register] === 0 ? 1 : 0);
    }

    cpu.setSubtractFlag(0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpDec8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x35) {
      let addr = cpu.HLIndirect;
      cpu.setHalfCarryFlag(memory.getByte(addr), -1);
      memory.getByte(addr) -= 1;
      cpu.setZeroFlag(memory.getByte(addr) === 0 ? 1 : 0);
    } else {
      const register = memory.getByte(this.address) * 2;
      cpu.setHalfCarryFlag(cpu.regs[register], -1);
      cpu.regs[register] -= 1;
      cpu.setZeroFlag(cpu.regs[register] === 0 ? 1 : 0);
    }

    cpu.setSubtractFlag(1);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRLCA extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const [carryBit, rotatedReg] = cpu.rotateLeftCarry(
      cpu.getCarryFlag(),
      cpu.regs[CPU.A]
    );
    cpu.regs[CPU.A] = rotatedReg;
    cpu.setCarryFlagDirect(carryBit);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRRCA extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const lsb = cpu.regs[CPU.A] & 1;
    cpu.regs[CPU.A] >>= 1;
    cpu.regs[CPU.A] |= cpu.getCarryFlag() << 7;
    cpu.setCarryFlagDirect(lsb);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRLA extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.regs[CPU.A] = cpu.rotateLeft(cpu.regs[CPU.A]);
    cpu.setCarryFlagDirect(cpu.regs[CPU.A] >> 7);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRL extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = memory.getByte(this.address) & 0xf;
    let value = 0;
    if (register === 6) {
      value = cpu.rotateLeft(cpu.HLIndirect);
      cpu.HLIndirect = value;
    } else {
      value = cpu.rotateLeft(cpu.regs[register]);
      cpu.regs[register] = value;
    }

    cpu.setCarryFlagDirect(value >> 7);
    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(value === 0 ? 1 : 0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRRA extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const lsb = cpu.regs[CPU.A] & 1;
    cpu.regs[CPU.A] >>= 1;
    cpu.regs[CPU.A] |= lsb << 7;
    cpu.setCarryFlagDirect(lsb);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpAddR16ToHL extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = memory.getByte(this.address) * 2;
    const r16 = (cpu.regs[register] << 8) | cpu.regs[register + 1];
    let hl = (cpu.regs[CPU.H] << 8) | cpu.regs[CPU.H];
    cpu.setHalfCarryFlag(r16, hl);
    cpu.setCarryFlag(r16, hl);
    hl += r16;
    cpu.setSubtractFlag(0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpStop extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.log(memory.getByte(this.address), "TODO: stop");
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpJRE extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const relativeOffset = cpu.regs[CPU.E];
    cpu.PC += cpu.twosComplementToNumber(relativeOffset);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpJRC extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    // On https://gbdev.io/gb-opcodes/optables/classic this memory.getByte(this.address) is an
    // r8, but pretty sure it should be a d8.
    const relativeOffset = cpu.twosComplementToNumber(memory.getByte(cpu.PC++));
    let condition = false;
    switch (memory.getByte(this.address)) {
      case 0x20:
        condition = cpu.getZeroFlag() !== 0;
        break;
      case 0x30:
        condition = cpu.getCarryFlag() !== 0;
        break;
      case 0x28:
        condition = cpu.getZeroFlag() === 0;
        break;
      case 0x38:
        condition = cpu.getCarryFlag() === 0;
        break;
      default:
        cpu.log(memory.getByte(this.address), "JRC condition not implement");
    }

    if (condition) {
      cpu.PC += relativeOffset;
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpCPL extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.regs[CPU.A] ^= 0xff;
    cpu.setZeroFlag(1);
    cpu.setSubtractFlag(1);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpXorR8 extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x7e) {
      cpu.regs[CPU.A] ^= cpu.HLIndirect;
    } else {
      const register = cpu.getBits(memory.getByte(this.address), 4, 5);
      cpu.regs[CPU.A] ^= cpu.regs[register];
    }
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
    cpu.setSubtractFlag(0);
    cpu.setCarryFlagDirect(0);
    cpu.setHalfCarryFlag(0, 0);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpCall extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const addrLow = memory.getByte(cpu.PC++);
    const addrHigh = memory.getByte(cpu.PC++);

    memory.setByte(cpu.SP--, cpu.PC >> 8);
    memory.setByte(cpu.SP--, cpu.PC & 0xff);

    cpu.PC = (addrHigh << 8) | addrLow;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRet extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const high = memory.getByte(cpu.SP--);
    const low = memory.getByte(cpu.SP--);
    cpu.PC = (high << 8) | low;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPush extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    let low = 0;
    let high = 0;
    if (memory.getByte(this.address) === 0xf5) {
      high = cpu.regs[CPU.A];
      low = cpu.regs[CPU.F];
    } else {
      const register = cpu.getBits(memory.getByte(this.address), 3, 5);
      high = cpu.regs[register];
      low = cpu.regs[register + 1];
    }

    memory.setByte(--cpu.SP, high);
    memory.setByte(--cpu.SP, low);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPop extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0xf1) {
      cpu.regs[CPU.A] = memory.getByte(cpu.SP--);
      cpu.regs[CPU.F] = memory.getByte(cpu.SP--);
    } else {
      const register = cpu.getBits(memory.getByte(this.address), 3, 5);
      cpu.regs[register] = memory.getByte(cpu.SP--);
      cpu.regs[register + 1] = memory.getByte(cpu.SP--);
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPrefix extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.prefix = true;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpBit extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = cpu.getBits(memory.getByte(this.address), 0, 2);
    const bit = cpu.getBits(memory.getByte(this.address), 3, 5);
    if (register === 0x6) {
      // (HL)
    } else {
      return cpu.getBits(cpu.regs[register], bit, bit);
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}
