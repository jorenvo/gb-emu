import { CPU } from "./cpu.js";
import { Memory } from "./memory.js";
import * as utils from "./utils.js";

export abstract class Instruction {
  protected address: number;

  constructor(address: number) {
    this.address = address;
  }

  movePCToNext(cpu: CPU) {
    cpu.PC += this.size();
  }

  getStringForR8(n: number) {
    switch (n) {
      case 0:
        return "B";
      case 1:
        return "C";
      case 2:
        return "D";
      case 3:
        return "E";
      case 4:
        return "H";
      case 5:
        return "L";
      case 6:
        return "F";
      case 7:
        return "A";
      default:
        throw new Error(`Register ${n} doesn't exist.`);
    }
  }

  getStringForR16(n: number) {
    switch (n) {
      case 0:
        return "BC";
      case 1:
        return "DE";
      case 2:
        return "HL";
      case 3:
        return "SP";
      default:
        throw new Error(`Register ${n} doesn't exist.`);
    }
  }

  abstract size(): number;
  abstract exec(cpu: CPU, memory: Memory): void;
  abstract disassemble(memory: Memory): string;
}

export class NotImplemented extends Instruction {
  size() {
    return 0;
  }

  exec(_cpu: CPU, memory: Memory) {
    utils.log(
      this.address,
      `Executing not implemented instruction with opcode ${memory.getByte(
        this.address
      )}`
    );
  }

  disassemble(memory: Memory) {
    return `NIP ${memory.getByte(this.address)}`;
  }
}

export class OpNop extends Instruction {
  size() {
    return 1;
  }

  exec(_cpu: CPU, _memory: Memory) {}

  disassemble(_memory: Memory) {
    return "NOP";
  }
}

export class OpLdD16ToR16 extends Instruction {
  size() {
    return 3;
  }

  exec(cpu: CPU, memory: Memory) {
    const d16High = memory.getByte(this.address + 1);
    const d16Low = memory.getByte(this.address + 2);

    if (memory.getByte(this.address) === 0x31) {
      cpu.SP = (d16High << 8) | d16Low;
    } else {
      const register = utils.getBits(memory.getByte(this.address), 4, 5) * 2;
      cpu.regs[register] = d16High;
      cpu.regs[register + 1] = d16Low;
    }
    this.movePCToNext(cpu);
  }

  disassemble(memory: Memory) {
    let reg;
    switch (memory.getByte(this.address) >> 4) {
      case 0x0:
        reg = "BC";
        break;
      case 0x1:
        reg = "DE";
        break;
      case 0x2:
        reg = "HL";
        break;
      case 0x3:
        reg = "SP";
        break;
      default:
        throw new Error("Unknown register!");
    }

    const d16Hex = utils.hexString(
      (memory.getByte(this.address + 1) << 8) |
        memory.getByte(this.address + 2),
      16
    );
    return `LD ${reg}, $${d16Hex}`;
  }
}

// autogenerated classes start here
// LD (HL), d8
// LD A, d8
export class OpLdD8ToR8 extends Instruction {
  size() {
    return 2;
  }

  getRegister(memory: Memory) {
    return (memory.getByte(this.address) >> 4) * 2;
  }

  isHL(memory: Memory) {
    return memory.getByte(this.address) === 0x36;
  }

  exec(cpu: CPU, memory: Memory) {
    const register = this.getRegister(memory);
    const d8 = memory.getByte(this.address + 1);
    if (this.isHL(memory)) {
      memory.setByte(cpu.getHL(), d8);
    } else {
      cpu.regs[register] = d8;
    }
    this.movePCToNext(cpu);
  }

  disassemble(memory: Memory) {
    const d8 = memory.getByte(this.address + 1);

    let dest = "(HL)";
    if (!this.isHL(memory)) {
      dest = this.getStringForR8(this.getRegister(memory));
    }

    return `LD ${dest}, $${utils.hexString(d8, 8)}`;
  }
}

export class OpLdR8ToA16 extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, memory: Memory) {
    let register = 0;
    switch (memory.getByte(this.address)) {
      case 0x02:
        register = 0;
        break;
      case 0x12:
        register = 2;
        break;
      case 0x22:
      case 0x32:
      case 0x70:
      case 0x71:
      case 0x72:
      case 0x73:
      case 0x74:
      case 0x75:
      case 0x77:
        register = 4;
        break;
    }
    const high = cpu.regs[register];
    const low = cpu.regs[register + 1];
    let addr = (high << 8) | low;
    memory.setByte(addr, cpu.regs[memory.getByte(this.address & 0b1111)]);

    switch (memory.getByte(this.address)) {
      case 0x22:
        cpu.setHL(cpu.getHL() + 1);
        break;
      case 0x32:
        cpu.setHL(cpu.getHL() - 1);
        break;
    }
  }

  disassemble(memory: Memory) {
    let dest = "";
    const byte = memory.getByte(this.address);
    switch (byte) {
      case 0x02:
        dest = "BC";
        break;
      case 0x12:
        dest = "DE";
        break;
      case 0x22:
        dest = "HL+";
        break;
      case 0x32:
        dest = "HL-";
        break;
      case 0x70:
      case 0x71:
      case 0x72:
      case 0x73:
      case 0x74:
      case 0x75:
      case 0x77:
        dest = "HL";
        break;
      default:
        utils.log(memory.getByte(this.address), "unknown opLdR8ToA16");
    }

    let src = "A";
    if (byte >> 4 === 7) {
      const reg = byte & 0b1111;
      src = this.getStringForR8(reg);
    }

    return `LD (${dest}) ${src}`;
  }
}

export class OpLdA16ToA extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, memory: Memory) {
    const register = memory.getByte(this.address) * 2;
    const aHigh = cpu.regs[register];
    const aLow = cpu.regs[register + 1];
    let addr = (aHigh << 8) | aLow;
    cpu.regs[CPU.A] = memory.getByte(addr);

    switch (memory.getByte(this.address)) {
      case 0x2a:
        cpu.setHL(cpu.getHL() + 1);
        break;
      case 0x3a:
        cpu.setHL(cpu.getHL() - 1);
        break;
    }
  }

  disassemble(memory: Memory) {
    let src = "";
    switch (memory.getByte(this.address)) {
      case 0x0a:
        src = "BC";
        break;
      case 0x1a:
        src = "DE";
        break;
      case 0x2a:
        src = "HL+";
        break;
      case 0x3a:
        src = "HL-";
        break;
      default:
        utils.log(memory.getByte(this.address), "unknown OpLdA16ToA");
    }

    return `LD A, (${src})`;
  }
}

export class OpLdAtoAddrC extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, memory: Memory) {
    memory.setByte(cpu.regs[CPU.C], cpu.regs[CPU.A]);
  }

  disassemble(_memory: Memory) {
    return "LD (C), A";
  }
}

export class OpLdSPToA16 extends Instruction {
  size() {
    return 3;
  }

  _a16(memory: Memory) {
    const a16Low = memory.getByte(this.address);
    const a16High = memory.getByte(this.address + 1);
    return (a16High << 8) | a16Low;
  }

  exec(cpu: CPU, memory: Memory) {
    const a16 = this._a16(memory);

    // TODO: this order is correct, should we always store LSB before MSB?
    memory.setByte(a16, cpu.SP & 0xff);
    memory.setByte(a16 + 1, cpu.SP >> 8);
  }

  disassemble(memory: Memory) {
    return `LD $${utils.hexString(this._a16(memory), 16)}, SP`;
  }
}

export class OpLdhA8 extends Instruction {
  size() {
    return 2;
  }

  _getAddr(memory: Memory) {
    return memory.getByte(this.address + 1);
  }

  exec(cpu: CPU, memory: Memory) {
    const lowAddr = this._getAddr(memory);
    memory.setByte(0xff00 | lowAddr, cpu.regs[CPU.A]);
  }

  disassemble(memory: Memory) {
    return `LDH ($${utils.hexString(this._getAddr(memory))}), A`;
  }
}

export class OpLdR8ToR8 extends Instruction {
  size() {
    return 1;
  }

  _getSrcReg(memory: Memory) {
    return utils.getBits(memory.getByte(this.address), 0, 2);
  }

  _getDestReg(memory: Memory) {
    return utils.getBits(memory.getByte(this.address), 3, 5);
  }

  exec(cpu: CPU, memory: Memory) {
    const srcReg = this._getSrcReg(memory);
    const destReg = this._getDestReg(memory);

    if (srcReg === 6) {
      cpu.regs[destReg] = memory.getByte(cpu.getHL());
    } else if (destReg === 6) {
      memory.setByte(cpu.getHL(), cpu.regs[srcReg]);
    } else {
      cpu.regs[destReg] = cpu.regs[srcReg];
    }
  }

  disassemble(memory: Memory) {
    const srcReg = this._getSrcReg(memory);
    const destReg = this._getDestReg(memory);

    let src = this.getStringForR8(srcReg);
    let dest = this.getStringForR8(destReg);

    if (srcReg === 6) {
      src = "(HL)";
    } else if (destReg === 6) {
      dest = "(HL)";
    }

    return `LD ${dest}, ${src}`;
  }
}

export abstract class OpDecInc16 extends Instruction {
  size() {
    return 1;
  }

  do(cpu: CPU, memory: Memory, inc: boolean) {
    // TODO: SP will be 0x3, check if that works
    const register = memory.getByte(this.address) * 2;
    const high = cpu.regs[register];
    const low = cpu.regs[register + 1];

    let r16 = (high << 8) | low;
    r16 += inc ? 1 : -1;
    cpu.regs[register] = r16 >> 8;
    cpu.regs[register + 1] = r16 & 0xff;
  }
}

export class OpInc16 extends OpDecInc16 {
  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x33) {
      ++cpu.SP;
    } else {
      super.do(cpu, memory, true);
    }
  }

  disassemble(memory: Memory) {
    const reg = this.getStringForR16(memory.getByte(this.address) >> 4);
    return `INC ${reg}`;
  }
}

export class OpDec16 extends OpDecInc16 {
  exec(cpu: CPU, memory: Memory) {
    super.do(cpu, memory, false); // TODO no special case for SP like in Inc?
  }

  disassemble(memory: Memory) {
    const reg = this.getStringForR16(memory.getByte(this.address) >> 4);
    return `DEC ${reg}`;
  }
}

export class OpInc8 extends Instruction {
  size() {
    return 1;
  }

  _getReg(memory: Memory) {
    const opcode = memory.getByte(this.address);
    switch (opcode) {
      case 0x04:
        return 0;
      case 0x14:
        return 2;
      case 0x24:
        return 4;
      case 0x0c:
        return 1;
      case 0x1c:
        return 3;
      case 0x2c:
        return 5;
      case 0x3c:
        return 7;
      default:
        throw new Error(`Unknown register for opcode ${opcode}`);
    }
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x34) {
      let addr = cpu.getHL();
      cpu.setHalfCarryFlag(memory.getByte(addr), 1);
      memory.setByte(addr, memory.getByte(addr) + 1);
      cpu.setZeroFlag(memory.getByte(addr) === 0 ? 1 : 0);
    } else {
      const register = this._getReg(memory);
      cpu.setHalfCarryFlag(cpu.regs[register], 1);
      cpu.regs[register] += 1;
      cpu.setZeroFlag(cpu.regs[register] === 0 ? 1 : 0);
    }

    cpu.setSubtractFlag(0);
  }

  disassemble(memory: Memory) {
    let reg = "";
    if (memory.getByte(this.address) === 0x34) {
      reg = "(HL)";
    } else {
      reg = this.getStringForR8(this._getReg(memory));
    }

    return `INC ${reg}`;
  }
}

export class OpDec8 extends Instruction {
  size() {
    return 1;
  }

  _getReg(memory: Memory) {
    const opcode = memory.getByte(this.address);
    switch (opcode) {
      case 0x05:
        return 0;
      case 0x15:
        return 2;
      case 0x25:
        return 4;
      case 0x0d:
        return 1;
      case 0x1d:
        return 3;
      case 0x2d:
        return 5;
      case 0x3d:
        return 7;
      default:
        throw new Error(`Unknown register for opcode ${opcode}`);
    }
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0x35) {
      let addr = cpu.getHL();
      cpu.setHalfCarryFlag(memory.getByte(addr), -1);
      memory.setByte(addr, memory.getByte(addr) - 1);
      cpu.setZeroFlag(memory.getByte(addr) === 0 ? 1 : 0);
    } else {
      const register = memory.getByte(this.address) * 2;
      cpu.setHalfCarryFlag(cpu.regs[register], -1);
      cpu.regs[register] -= 1;
      cpu.setZeroFlag(cpu.regs[register] === 0 ? 1 : 0);
    }

    cpu.setSubtractFlag(1);
  }

  disassemble(memory: Memory) {
    let reg = "";
    if (memory.getByte(this.address) === 0x35) {
      reg = "(HL)";
    } else {
      reg = this.getStringForR8(this._getReg(memory));
    }

    return `DEC ${reg}`;
  }
}

export class OpRLCA extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, memory: Memory) {
    const [carryBit, rotatedReg] = cpu.rotateLeftCarry(
      cpu.getCarryFlag(),
      cpu.regs[CPU.A]
    );
    cpu.regs[CPU.A] = rotatedReg;
    cpu.setCarryFlagDirect(carryBit);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(_memory: Memory) {
    return "RLCA";
  }
}

export class OpRRCA extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, memory: Memory) {
    const lsb = cpu.regs[CPU.A] & 1;
    cpu.regs[CPU.A] >>= 1;
    cpu.regs[CPU.A] |= cpu.getCarryFlag() << 7;
    cpu.setCarryFlagDirect(lsb);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(_memory: Memory) {
    return "RRCA";
  }
}

export class OpRLA extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, _memory: Memory) {
    cpu.regs[CPU.A] = cpu.rotateLeft(cpu.regs[CPU.A]);
    cpu.setCarryFlagDirect(cpu.regs[CPU.A] >> 7);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
  }

  disassemble(_memory: Memory) {
    return "RLA";
  }
}

export class OpRL extends Instruction {
  size() {
    return 2;
  }

  _getReg(memory: Memory) {
    return memory.getByte(this.address + 1) & 0xf;
  }

  exec(cpu: CPU, memory: Memory) {
    const register = this._getReg(memory);
    let value = 0;
    if (register === 6) {
      value = cpu.rotateLeft(cpu.getHL());
      cpu.setHL(value);
    } else {
      value = cpu.rotateLeft(cpu.regs[register]);
      cpu.regs[register] = value;
    }

    cpu.setCarryFlagDirect(value >> 7);
    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(value === 0 ? 1 : 0);
  }

  disassemble(memory: Memory) {
    const reg = this._getReg(memory);
    let regString = "(HL)";
    if (reg !== 6) {
      regString = this.getStringForR8(reg);
    }

    return `RL ${regString}`;
  }
}

export class OpRRA extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, _memory: Memory) {
    const lsb = cpu.regs[CPU.A] & 1;
    cpu.regs[CPU.A] >>= 1;
    cpu.regs[CPU.A] |= lsb << 7;
    cpu.setCarryFlagDirect(lsb);

    cpu.setHalfCarryFlag(0, 0);
    cpu.setSubtractFlag(0);
    cpu.setZeroFlag(0);
  }

  disassemble(_memory: Memory) {
    return "RRA";
  }
}

export class OpAddR16ToHL extends Instruction {
  size() {
    return 1;
  }

  _getReg(memory: Memory) {
    return (memory.getByte(this.address) >> 4) * 2;
  }

  exec(cpu: CPU, memory: Memory) {
    const register = this._getReg(memory);
    const r16 = cpu.getCombinedRegister(register, register + 1);
    let hl = cpu.getHL();
    cpu.setHalfCarryFlag(r16, hl);
    cpu.setCarryFlag(r16, hl);
    cpu.setHL(hl + r16);
    cpu.setSubtractFlag(0);
  }

  disassemble(memory: Memory) {
    const reg = this.getStringForR16(this._getReg(memory));
    return `ADD HL, ${reg}`;
  }
}

export class OpStop extends Instruction {
  size() {
    return 1;
  }

  exec(_cpu: CPU, memory: Memory) {
    utils.log(memory.getByte(this.address), "TODO: stop");
  }

  disassemble(_memory: Memory) {
    return "STOP";
  }
}

export class OpJR extends Instruction {
  size() {
    return 2;
  }

  private getRelativeOffset(memory: Memory) {
    return utils.twosComplementToNumber(memory.getByte(this.address + 1));
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.PC += this.getRelativeOffset(memory);
  }

  disassemble(memory: Memory) {
    return `JR $${utils.hexString(this.getRelativeOffset(memory))}`;
  }
}

export class OpJRC extends Instruction {
  size() {
    return 2;
  }

  private getRelativeOffset(memory: Memory) {
    return utils.twosComplementToNumber(memory.getByte(this.address + 1));
  }

  exec(cpu: CPU, memory: Memory) {
    let condition = false;
    switch (memory.getByte(this.address)) {
      case 0x20:
        condition = cpu.getZeroFlag() !== 0;
        break;
      case 0x30:
        condition = cpu.getCarryFlag() !== 0;
        break;
      case 0x28:
        condition = cpu.getZeroFlag() === 0;
        break;
      case 0x38:
        condition = cpu.getCarryFlag() === 0;
        break;
      default:
        utils.log(memory.getByte(this.address), "JRC condition not implement");
    }

    if (condition) {
      cpu.PC += this.getRelativeOffset(memory);
    }
  }

  disassemble(memory: Memory) {
    let condition = "";
    switch (memory.getByte(this.address)) {
      case 0x20:
        condition = "NZ";
        break;
      case 0x30:
        condition = "NC";
        break;
      case 0x28:
        condition = "Z";
        break;
      case 0x38:
        condition = "C";
        break;
      default:
        condition = "UNS";
        break;
    }
    return `JR ${condition} $${utils.hexString(
      this.getRelativeOffset(memory)
    )}`;
  }
}

export class OpCPL extends Instruction {
  size() {
    return 1;
  }

  exec(cpu: CPU, _memory: Memory) {
    cpu.regs[CPU.A] ^= 0xff;
    cpu.setZeroFlag(1);
    cpu.setSubtractFlag(1);
  }

  disassemble(_memory: Memory) {
    return "CPL";
  }
}

export class OpXorR8 extends Instruction {
  size() {
    return 1;
  }

  _isHL(memory: Memory) {
    return memory.getByte(this.address) === 0x7e;
  }

  exec(cpu: CPU, memory: Memory) {
    if (this._isHL(memory)) {
      cpu.regs[CPU.A] ^= cpu.getHL();
    } else {
      const register = utils.getBits(memory.getByte(this.address), 4, 5);
      cpu.regs[CPU.A] ^= cpu.regs[register];
    }
    cpu.setZeroFlag(cpu.regs[CPU.A] === 0 ? 1 : 0);
    cpu.setSubtractFlag(0);
    cpu.setCarryFlagDirect(0);
    cpu.setHalfCarryFlag(0, 0);
  }

  disassemble(memory: Memory) {
    let reg = "(HL)";
    if (!this._isHL(memory)) {
      let byte = memory.getByte(this.address);
      reg = this.getStringForR8(byte);
    }

    return `XOR ${reg}`;
  }
}

export class OpCall extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const addrLow = memory.getByte(cpu.PC++);
    const addrHigh = memory.getByte(cpu.PC++);

    memory.setByte(cpu.SP--, cpu.PC >> 8);
    memory.setByte(cpu.SP--, cpu.PC & 0xff);

    cpu.PC = (addrHigh << 8) | addrLow;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpRet extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const high = memory.getByte(cpu.SP--);
    const low = memory.getByte(cpu.SP--);
    cpu.PC = (high << 8) | low;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPush extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    let low = 0;
    let high = 0;
    if (memory.getByte(this.address) === 0xf5) {
      high = cpu.regs[CPU.A];
      low = cpu.regs[CPU.F];
    } else {
      const register = utils.getBits(memory.getByte(this.address), 3, 5);
      high = cpu.regs[register];
      low = cpu.regs[register + 1];
    }

    memory.setByte(--cpu.SP, high);
    memory.setByte(--cpu.SP, low);
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPop extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    if (memory.getByte(this.address) === 0xf1) {
      cpu.regs[CPU.A] = memory.getByte(cpu.SP--);
      cpu.regs[CPU.F] = memory.getByte(cpu.SP--);
    } else {
      const register = utils.getBits(memory.getByte(this.address), 3, 5);
      cpu.regs[register] = memory.getByte(cpu.SP--);
      cpu.regs[register + 1] = memory.getByte(cpu.SP--);
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpPrefix extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    cpu.prefix = true;
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}

export class OpBit extends Instruction {
  size() {
    return 0; // TODO
  }

  exec(cpu: CPU, memory: Memory) {
    const register = utils.getBits(memory.getByte(this.address), 0, 2);
    const bit = utils.getBits(memory.getByte(this.address), 3, 5);
    if (register === 0x6) {
      // (HL)
    } else {
      return utils.getBits(cpu.regs[register], bit, bit);
    }
  }

  disassemble(memory: Memory) {
    return `TODO`;
  }
}
